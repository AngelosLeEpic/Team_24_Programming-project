class WidgetDropDown extends Widget{
  String[] elements;
  boolean amIActive = false;
  int numOfDropsToDisplay = 5;
  int currentlySelectedElement = -1;
  PFont font;
  int scrollIndex = 0; // This index tells the programme how far down the user has scrolled
  WidgetDropDown(int x, int y, int wide, int high ,PFont myFont, String[] input)
  {
    super(x,y,wide,high, 0);
    font = myFont;
    elements = input;
  }
  
  // initiates the drop down
  void initiativeDropDown() {
    searchBarUpdated();
    isDropDownActive = true;

    this.amIActive = true;
  }
  void removeDropDown(){
    scrollIndex = 0;
    isDropDownActive = false;
    this.amIActive = false;
  }
  void scroll(int i){
    scrollIndex += i;
    if(scrollIndex < 0) { scrollIndex = 0 ;}
    if(scrollIndex > - numOfDropsToDisplay + elements.length)
    {
      scrollIndex = elements.length - numOfDropsToDisplay;
    }
  }
  void render(){
    fill(screen.SECONDARY_COLOR);
    rect(xpos, ypos, wide, high,10,10,0,0);
    if(amIActive)
    {
      renderDrops();
    } else 
    {
      fill(screen.TEXT_COLOR);
      textAlign(LEFT, CENTER);
      if(currentlySelectedElement != -1)
      {
        text(elements[currentlySelectedElement], xpos + 5, ypos + high/3);
      }
    }
  }
  void renderDrops()
  {
    textFont(TextBoxFont);
    for(int i = 0; i < numOfDropsToDisplay; i++)
    {
      fill(screen.TERTIARY_COLOR);
      rect(xpos, ypos + high * (i + 1), wide, high);
      fill(screen.TEXT_COLOR);
      textAlign(LEFT, CENTER);
      text(elements[i + scrollIndex], xpos + 5, ypos + high/3 + high * (i + 1));
    }
  }
  void isClicked(){
    if(isMouseover() && !amIActive)
    {
      initiativeDropDown();
    } else if(amIActive && isMouseover()) // if the user clicked the original button, (which is empty)
    {
      currentlySelectedElement = -1; // We reset the value selected to be nothing
      removeDropDown();
    }
    else if(amIActive)
    {
      for(int i = 0; i < numOfDropsToDisplay; i++)
      {
        if((xpos < mouseX && xpos + wide > mouseX) && (ypos + (high * (i + 1)) < mouseY && ((ypos + (high * (i + 1))) + high > mouseY))) // We go through every element in the drop box
        {
          currentlySelectedElement = i + scrollIndex;
          removeDropDown();
          break;
        }
      }
      removeDropDown();
    }
  }

  // Method called if dropdown is active, allows the drop down to accept text input and avoid displaying datapoints that do not match what the user is typing
  void searchBarinput(char input) {
    try
    {
      if ((int)input == 8)
      { // the user pressed backspace
        backSpacePressed();
        searchBarUpdated();
      } else {
        input =  Character.toUpperCase(input);
        Search += input;
        searchBarUpdated();
      }
      scrollIndex = 0;
    }
    catch (Exception e)
    {
      // do nothing if we could not process the user input
      // most likely the user pressed an input that we did not expect, and failed at the Character.toUpperCase line, in which case we don't care
    }
  }

  // Method called  when user changes anything in the search bar, it filters the elements array to the arraylist of topDisplay when called.
  void searchBarUpdated() {
    validData.clear();
    for (String element : elements) {
      if (element.startsWith(Search)) {
        validData.add(element);
      }
    }
  }
  // method to be executed if user pressed backspace while typing on the drop down search bar
  void backSpacePressed() {
    try
    {
      Search = Search.substring(0, Search.length() - 1); // remove the last character if the user presses backspace
    }
    catch ( Exception e)
    {
      Search = "";
      // The user used backspace even tho nothing is written, do nothing
    }
  }
}
